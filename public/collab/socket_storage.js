// Generated by CoffeeScript 1.6.3
/*
#SocketStorage#

This is a Socket storage adaptor needed to connect Batman's models to websocket
It has not been finished yet.
*/


(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Batman.SocketStorage = (function(_super) {
    __extends(SocketStorage, _super);

    /*
    #SocketStorage#
    
    This is a Socket storage adaptor needed to connect Batman's models to websocket
    It has not been finished yet.
    */


    function SocketStorage(model) {
      /*
        Initialize storage adaptor as well as socket
      */

      SocketStorage.__super__.constructor.call(this, model);
      this.socket = new Batman.Socket.getInstance();
    }

    SocketStorage.prototype._dataMatches = function(conditions, data) {
      var k, match, v;
      match = true;
      for (k in conditions) {
        v = conditions[k];
        if (data[k] !== v) {
          match = false;
          break;
        }
      }
      return match;
    };

    SocketStorage.prototype.subscribe = function(model) {
      /*
        Subscribe model to different events
        subscribe function is called after readall
      */

      var channel, key,
        _this = this;
      channel = this.socket.getChannel(model.storageKey);
      if (model.primaryKey != null) {
        key = model.primaryKey;
      } else {
        key = "id";
      }
      channel.on("push", function(event) {
        var all, record, res;
        all = model.get("loaded");
        res = all.find(function(item) {
          return item.get(key) === event.content[key];
        });
        all.remove(res);
        record = _this.getRecordFromData(event.content, model);
        return all.add(record);
      });
      channel.on("delete", function(event) {
        var all, res;
        all = model.get("loaded");
        res = all.find(function(item) {
          return item.get(key) === event.content[key];
        });
        return all.remove(res);
      });
      return channel;
    };

    SocketStorage.prototype.readAll = function(env, next) {
      /*
      overrided readAll to add subscription
      TODO: what to do with subscriptions if readALL is called several times?
      */

      var channel, options;
      channel = this.subscribe(env.subject);
      options = env.options.data;
      channel.onNextMessage(function(event) {
        var error, item, records, _i, _len, _ref;
        try {
          records = [];
          if ((event.content != null) && (event.content.length != null)) {
            _ref = event.content;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              item = _ref[_i];
              if (this._dataMatches(options, item)) {
                records.push(item);
              }
            }
          }
          env.recordsAttributes = records;
        } catch (_error) {
          error = _error;
          env.error = error;
        }
        return next();
      });
      return channel.readAll();
    };

    SocketStorage.prototype.create = function(_arg, next) {
      var channel, id, key, recordAttributes;
      key = _arg.key, id = _arg.id, recordAttributes = _arg.recordAttributes;
      channel = this.socket.getChannel(key);
      channel.save(recordAttributes, id);
      return next();
    };

    SocketStorage.prototype.read = function(_arg, next) {
      var channel, id, key, recordAttributes,
        _this = this;
      key = _arg.key, id = _arg.id, recordAttributes = _arg.recordAttributes;
      channel = this.socket.getChannel(key);
      channel.onNextMessage(function() {
        if (!env.recordAttributes) {
          env.error = new _this.constructor.NotFoundError();
          return next();
        }
      });
      return channel.read(id);
    };

    SocketStorage.prototype.update = function(_arg, next) {
      var channel, id, key, recordAttributes;
      key = _arg.key, id = _arg.id, recordAttributes = _arg.recordAttributes;
      channel = this.socket.getChannel(key);
      channel.save(recordAttributes, id);
      return next();
    };

    SocketStorage.prototype.destroy = function(_arg, next) {
      var channel, id, key;
      key = _arg.key, id = _arg.id;
      channel = this.socket.getChannel(key);
      channel.remove(id);
      return next();
    };

    SocketStorage.prototype.before('read', 'create', 'update', 'destroy', SocketStorage.skipIfError(function(env, next) {
      var key,
        _this = this;
      if (env.action === 'create') {
        env.id = env.subject.get('id') || env.subject._withoutDirtyTracking(function() {
          return env.subject.set('id', Batman.SocketEvent.genId());
        });
      } else {
        env.id = env.subject.get('id');
      }
      if (env.id == null) {
        env.error = new this.constructor.StorageError("Couldn't get/set record primary key on " + env.action + "!");
      }
      key = this.storageKey(env.subject);
      env.key = key;
      return next();
    }));

    SocketStorage.prototype.before('create', 'update', SocketStorage.skipIfError(function(env, next) {
      env.recordAttributes = JSON.stringify(env.subject);
      return next();
    }));

    SocketStorage.prototype.after('read', SocketStorage.skipIfError(function(env, next) {
      var error;
      if (typeof env.recordAttributes === 'string') {
        try {
          env.recordAttributes = this._jsonToAttributes(env.recordAttributes);
        } catch (_error) {
          error = _error;
          env.error = error;
        }
        return next();
      }
      env.subject._withoutDirtyTracking(function() {
        return this.fromJSON(env.recordAttributes);
      });
      return next();
    }));

    SocketStorage.prototype.after('read', 'create', 'update', 'destroy', SocketStorage.skipIfError(function(env, next) {
      env.result = env.subject;
      return next();
    }));

    SocketStorage.prototype.after('readAll', SocketStorage.skipIfError(function(env, next) {
      var recordAttributes;
      env.result = env.records = (function() {
        var _i, _len, _ref, _results;
        _ref = env.recordsAttributes;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          recordAttributes = _ref[_i];
          _results.push(this.getRecordFromData(recordAttributes, env.subject));
        }
        return _results;
      }).call(this);
      return next();
    }));

    return SocketStorage;

  })(Batman.StorageAdapter);

}).call(this);

/*
//@ sourceMappingURL=socket_storage.map
*/
