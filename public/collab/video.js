// Generated by CoffeeScript 1.6.3
/*
  video channel class, temporal version
  will be refactored in the future
*/


(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Batman.VideoChannel = (function(_super) {
    __extends(VideoChannel, _super);

    VideoChannel.prototype.peer = null;

    /*
      mystream is a temporal global variable to save a stream from a webcome
    */


    function VideoChannel(name, room, myStream) {
      var _this = this;
      this.room = room;
      this.myStream = myStream != null ? myStream : null;
      this.attach = __bind(this.attach, this);
      this.attach = __bind(this.attach, this);
      this.subscribeRemote = __bind(this.subscribeRemote, this);
      this.subscribeLocal = __bind(this.subscribeLocal, this);
      this.onGetICE = __bind(this.onGetICE, this);
      this.onCreateICE = __bind(this.onCreateICE, this);
      this.onGetRemoteStream = __bind(this.onGetRemoteStream, this);
      this.onGetAnswer = __bind(this.onGetAnswer, this);
      this.onCreateAnswer = __bind(this.onCreateAnswer, this);
      this.onGetOffer = __bind(this.onGetOffer, this);
      this.onCreateOffer = __bind(this.onCreateOffer, this);
      this.call = __bind(this.call, this);
      this.onWebCamSuccess = __bind(this.onWebCamSuccess, this);
      this.makePeer = __bind(this.makePeer, this);
      this.startPeer = __bind(this.startPeer, this);
      this.askWebcam = __bind(this.askWebcam, this);
      VideoChannel.__super__.constructor.call(this, name);
      this.set("src", "");
      this.startPeer();
      this.on("ICE", function(event) {
        return _this.onGetICE(event.content);
      });
      this.on("offer", function(event) {
        return _this.onGetOffer(event.content);
      });
      this.on("answer", function(event) {
        return _this.onGetAnswer(event.content);
      });
    }

    VideoChannel.prototype.askWebcam = function() {
      return this.ask("webcam");
    };

    VideoChannel.prototype.startPeer = function(servers) {
      if (servers == null) {
        servers = null;
      }
      /*
      starts p2p connection
      */

      this.peer = this.makePeer();
      this.peer.onicecandidate = this.onCreateICE;
      return this.peer.onaddstream = this.onGetRemoteStream;
    };

    VideoChannel.prototype.makePeer = function(servers) {
      if (servers == null) {
        servers = null;
      }
      if (window.RTCPeerConnection != null) {
        return new RTCPeerConnection(servers);
      } else {
        if (window.mozRTCPeerConnection != null) {
          return new mozRTCPeerConnection(servers);
        } else {
          return new webkitRTCPeerConnection(servers);
        }
      }
    };

    VideoChannel.prototype.onWebCamSuccess = function(stream) {
      /*
        when webcam stream received
      */

      var _this = this;
      this.myStream = stream;
      this.peer.onaddstream = function(st) {};
      this.peer.addStream(stream);
      this.peer.onaddstream = this.onGetRemoteStream;
      return this.fire("localStream", stream);
    };

    VideoChannel.prototype.call = function() {
      /*
        Makes a call
      */

      console.log("VideoChannel CALL from " + this.name + " 2 " + this.room);
      if (this.myStream != null) {
        return this.peer.createOffer(this.onCreateOffer);
      } else {
        this.askWebcam();
        return this.on("localStream", this.call);
      }
    };

    VideoChannel.prototype.onCreateOffer = function(desc) {
      /*
        fires when you propose and offer
      */

      var offer;
      this.peer.setLocalDescription(desc);
      offer = Batman.SocketEvent.makeEvent(desc, this.name, "offer", this.room);
      return this.fire("send", offer);
    };

    VideoChannel.prototype.onGetOffer = function(event) {
      /*
        fires when you received another's offer
      */

      var desc;
      desc = new RTCSessionDescription(event);
      this.peer.setRemoteDescription(desc);
      this.peer.createAnswer(this.onCreateAnswer);
      return console.log("offer received");
    };

    VideoChannel.prototype.onCreateAnswer = function(desc) {
      /*
        fires when you created an answer
      */

      var answer;
      this.peer.setLocalDescription(desc);
      answer = Batman.SocketEvent.makeEvent(desc, this.name, "answer", this.room);
      return this.fire("send", answer);
    };

    VideoChannel.prototype.onGetAnswer = function(event) {
      /*
        fires when you received an answer
      */

      var desc;
      desc = new RTCSessionDescription(event);
      this.peer.setRemoteDescription(desc);
      return console.log("answer received");
    };

    VideoChannel.prototype.onGetRemoteStream = function(e) {
      /*
        fires when you got stream
      */

      var stream;
      console.log("got remote stream");
      if (e.stream != null) {
        stream = e.stream;
        return this.fire("remoteStream", stream);
      } else {
        return alert("bug in onGetRemoteStream");
      }
    };

    VideoChannel.prototype.onCreateICE = function(event) {
      /*
        fires when you make an ICE candidates
      */

      var cand, evt;
      if (event.candidate != null) {
        cand = event.candidate;
        evt = Batman.SocketEvent.makeEvent(cand, this.name, "ICE", this.room);
        return this.fire("send", evt);
      }
    };

    /*
    else
      alert "onICE do not work well"
      alert JSON.stringify(event)
    */


    VideoChannel.prototype.onGetICE = function(event) {
      /*
        fires when you received and ICE
      */

      return this.peer.addIceCandidate(new RTCIceCandidate(event));
    };

    /*
    onmessage: (event)=>
      switch event.request
        when "ICE" then @onGetICE(event.content)
        when "offer" then  @onGetOffer(event.content)
        when "answer" then @onGetAnswer(event.content)
    */


    VideoChannel.prototype.onError = function(e) {
      return alert("There has been a problem retrieving the streams - did you allow access?");
    };

    VideoChannel.prototype.subscribeLocal = function(vid) {
      var _this = this;
      return this.on("localStream", function(stream) {
        var src;
        src = _this.stream2src(stream);
        _this.set("src", src);
        return vid.src = src;
      });
    };

    VideoChannel.prototype.subscribeRemote = function(vid) {
      var _this = this;
      return this.on("remoteStream", function(stream) {
        var src;
        src = _this.stream2src(stream);
        _this.set("src", src);
        return vid.src = src;
      });
    };

    VideoChannel.prototype.attach = function(obj) {
      /*
        Attaches the channel to the socket wrapper and subscribes to its events
      */

      var cl, receive, send;
      receive = this.receive;
      if ((this.room != null) && this.room !== "all") {
        obj.on(this.name + "2" + this.room, receive);
      } else {
        obj.on(this.name, receive);
      }
      obj.on("all", receive);
      send = obj.send;
      this.on("send", send);
      this.on("ask", obj.ask);
      cl = this.constructor.name;
      obj.fire(cl, this.name);
      return this;
    };

    VideoChannel.prototype.attach = function(obj) {
      var onStream;
      onStream = this.onWebCamSuccess;
      obj.on("localStream", onStream);
      VideoChannel.__super__.attach.call(this, obj);
      if (this.myStream != null) {
        this.peer.addStream(this.myStream);
        this.peer.onaddstream = this.onGetRemoteStream;
      } else {
        this.askWebcam();
      }
      return this;
    };

    return VideoChannel;

  })(Batman.Channel);

  Batman.VideoSlotChannel = (function(_super) {
    __extends(VideoSlotChannel, _super);

    VideoSlotChannel.prototype.channels = null;

    VideoSlotChannel.prototype.OPEN_PEERS = "openpeers";

    VideoSlotChannel.prototype.PEERS_OPENED = "peersopened";

    VideoSlotChannel.prototype.CALL_PEERS = "callpeers";

    VideoSlotChannel.prototype.PEERS_CALLED = "peerscalled";

    VideoSlotChannel.prototype.CLOSE_PEERS = "closepeers";

    VideoSlotChannel.prototype.PEERS_CLOSED = "peersclosed";

    /*
      mystream is a temporal global variable to save a stream from a webcome
    */


    function VideoSlotChannel(name, room) {
      var _this = this;
      this.room = room;
      this.open = __bind(this.open, this);
      this.call = __bind(this.call, this);
      this.peersCalled = __bind(this.peersCalled, this);
      this.peersOpened = __bind(this.peersOpened, this);
      VideoSlotChannel.__super__.constructor.call(this, name);
      this.channels = new Batman.SimpleHash();
      this.on(this.OPEN_PEERS, function(event) {
        return _this.peersOpened(event);
      });
      this.on(this.CALL_PEERS, function(event) {
        return _this.peersCalled(event);
      });
    }

    VideoSlotChannel.prototype.peersOpened = function(event) {
      /*
        fires when we received peers to be created
      */

      var ch, cont, f, h, socket, t, _i, _j, _len, _len1, _ref, _ref1,
        _this = this;
      console.log("PEERS OPENED: " + JSON.stringify(event));
      if (!event.content) {
        console.log("no content");
      }
      cont = event.content;
      if (!((cont.from != null) || cont.to)) {
        console.log("no from or to");
      }
      socket = Batman.Socket.getInstance();
      _ref = cont.from;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        f = _ref[_i];
        h = this.channels.getOrSet(f, function() {
          return new Batman.SimpleHash();
        });
        _ref1 = cont.to;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          t = _ref1[_j];
          console.log("open video channel from " + f + " to " + t);
          ch = h.getOrSet(t, function() {
            return socket.getVideoChannel(f, t);
          });
          ch.on("localStream", function(stream) {
            return _this.fire("local", _this.stream2src(stream));
          });
          ch.on("remoteStream", function(stream) {
            var src;
            src = _this.stream2src(stream);
            console.log("" + _this.name + ": remoteSRC = " + src);
            return _this.fire("remote", src);
          });
        }
      }
      event.content.name = this.PEERS_OPENED;
      event.request = this.PEERS_OPENED;
      event.room = this.room;
      this.send(event);
      return this.fire(this.PEERS_OPENED);
    };

    VideoSlotChannel.prototype.peersCalled = function(event) {
      /*
        fires when we received peers to be created
      */

      var ch, cont, f, h, socket, t, _i, _j, _len, _len1, _ref, _ref1,
        _this = this;
      console.log("PEERS CALLED: " + JSON.stringify(event));
      if (!event.content) {
        console.log("no content");
      }
      cont = event.content;
      if (!((cont.from != null) || cont.to)) {
        console.log("no from or to");
      }
      socket = Batman.Socket.getInstance();
      _ref = cont.from;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        f = _ref[_i];
        h = this.channels.getOrSet(f, function() {
          return new Batman.SimpleHash();
        });
        _ref1 = cont.to;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          t = _ref1[_j];
          console.log("call video channel from " + f + " to " + t);
          ch = h.getOrSet(t, function() {
            return socket.getVideoChannel(f, t);
          });
          ch.call();
        }
      }
      event.content.name = this.PEERS_CALLED;
      event.request = this.PEERS_CALLED;
      event.room = this.room;
      this.send(event);
      return this.fire(this.PEERS_CALLED);
    };

    VideoSlotChannel.prototype.call = function() {
      var evt, req;
      req = "broadcast";
      evt = new Batman.SocketEvent(req, this.name, req, this.room);
      return this.fire("send", evt);
    };

    VideoSlotChannel.prototype.open = function() {
      var content, evt, req;
      req = "video";
      content = {
        name: req
      };
      evt = new Batman.SocketEvent(content, this.name, req, this.room);
      return this.fire("send", evt);
    };

    VideoSlotChannel.prototype.onError = function(e) {
      return alert("There has been a problem with slot channel?");
    };

    return VideoSlotChannel;

  })(Batman.Channel);

}).call(this);

/*
//@ sourceMappingURL=video.map
*/
