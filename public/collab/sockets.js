// Generated by CoffeeScript 1.6.3
/*
# SocketEvent class #
Socket Event class is a class that does all conversions and packing of events send by sockets and channels
*/


(function() {
  var _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Batman.SocketEvent = (function() {
    /*
    Socket Event class is a class that does all conversions and packing of events send by sockets and channels
    it contains a lot of useful static helpers to generate events that needed
    */

    function SocketEvent(content, channel, request, room) {
      this.content = content;
      this.channel = channel;
      this.request = request != null ? request : "push";
      this.room = room != null ? room : "all";
      /*
        creates websocket event where
        content is inside content variable, channel is for source (model) or type of content
        request is for what you want to do with content
        room is for what users to you want to spread this info
      */

      if (!((this.content.id != null) || this.content.query)) {
        this.content.id = SocketEvent.genId();
      }
    }

    SocketEvent.makeEvent = function(content, channel, req, room) {
      if (room == null) {
        room = "all";
      }
      /*
        creates a socketevent, where:
        content is content of event
        channel is name of the channel that is used for this event
        req is a request with what this event is send
        room is an info to which users should the event be sent to
      */

      return new Batman.SocketEvent(content, channel, req, room);
    };

    SocketEvent.makeQueryEvent = function(query, channel, room) {
      if (room == null) {
        room = "all";
      }
      return Batman.SocketEvent.makeEvent({
        query: query
      }, channel, "read", room);
    };

    SocketEvent.makeLookupEvent = function(lField, lQuery, channel, room) {
      var content;
      if (room == null) {
        room = "me";
      }
      content = {
        field: lField,
        query: lQuery
      };
      return Batman.SocketEvent.makeEvent(content, channel, "lookup", room);
    };

    SocketEvent.makePushEvent = function(content, channel, room) {
      if (room == null) {
        room = "all";
      }
      return Batman.SocketEvent.makeEvent(content, channel, "push", room);
    };

    SocketEvent.makeReadEvent = function(id, channel, room) {
      if (room == null) {
        room = "all";
      }
      return Batman.SocketEvent.makeEvent({
        id: id
      }, channel, "read", room);
    };

    SocketEvent.makeReadAllEvent = function(channel, room) {
      if (room == null) {
        room = "all";
      }
      return Batman.SocketEvent.makeEvent({
        query: "all"
      }, channel, "read", room);
    };

    SocketEvent.makeSaveEvent = function(obj, channel) {
      var data;
      data = Batman.SocketEvent.fromData(obj);
      data.channel = channel;
      data.request = "save";
      data.room = "all";
      return data;
    };

    SocketEvent.makeRemoveEvent = function(id, channel, room) {
      if (room == null) {
        room = "all";
      }
      return Batman.SocketEvent.makeEvent({
        id: id
      }, channel, "delete", room);
    };

    SocketEvent.fromEvent = function(event) {
      /*
      factory that generate SocketEvent from websocket event
      */

      if (event instanceof Batman.SocketEvent) {
        return event;
      }
      if (event.data == null) {
        throw new Error("No data inside of websocket event");
      }
      return this.fromData(event.data);
    };

    SocketEvent.genId = function() {
      /*
      ##Generates GUI as id for a record
      */

      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
        var r, v;
        r = Math.random() * 16 | 0;
        v = (c === "x" ? r : r & 0x3 | 0x8);
        return v.toString(16);
      });
    };

    SocketEvent.fromData = function(data) {
      /*
      factory that generate SocketEvent from the data
      */

      var channel, content, request, room;
      if (data instanceof Batman.SocketEvent) {
        return data;
      }
      if (typeof data === "string") {
        return this.fromString(data);
      }
      if (data.data != null) {
        data = data.data;
      }
      channel = data.channel != null ? data.channel : "default";
      content = data.content != null ? typeof data.content === "string" ? this.toJSON(data.content) : data.content : data;
      request = data.request != null ? data.request : "push";
      room = data.room != null ? data.room : "all";
      return new Batman.SocketEvent(content, channel, request, room);
    };

    SocketEvent.fromString = function(str) {
      /*
      factory that generate SocketEvent from some string
      */

      var data;
      data = this.toJSON(str);
      if (data === void 0 || typeof data === "string") {
        return new Batman.SocketEvent(str, "default", "save");
      } else {
        return this.fromData(data);
      }
    };

    SocketEvent.toJSON = function(str) {
      /*
      tries to convert string to json, returns initial string if failed
      */

      var e, obj;
      if (typeof str !== "string") {
        return str;
      }
      try {
        obj = JSON.parse(str);
      } catch (_error) {
        e = _error;
      }
      return str;
      if (obj === void 0) {
        return str;
      } else {
        return obj;
      }
    };

    return SocketEvent;

  })();

  /*
  # Channel class #
  Every sockets info to channels.
  Channels are needed to communicate directly with the model
  */


  Batman.Channel = (function(_super) {
    __extends(Channel, _super);

    /*
    #Channel class
    Every sockets info to channels.
    Channels are needed to communicate directly with the model
    */


    function Channel(name) {
      this.attach = __bind(this.attach, this);
      this.ask = __bind(this.ask, this);
      this.onmessage = __bind(this.onmessage, this);
      this.onNextMessage = __bind(this.onNextMessage, this);
      this.receive = __bind(this.receive, this);
      this.send = __bind(this.send, this);
      this.askWebcam = __bind(this.askWebcam, this);
      this.stream2src = __bind(this.stream2src, this);
      this.query = __bind(this.query, this);
      this.lookup = __bind(this.lookup, this);
      this.remove = __bind(this.remove, this);
      this.readAll = __bind(this.readAll, this);
      this.read = __bind(this.read, this);
      this.save = __bind(this.save, this);
      this.save = __bind(this.save, this);
      var _this = this;
      this.name = name;
      this.on("onmessage", function(event) {
        return _this.onmessage(event);
      });
    }

    Channel.prototype.save = function(obj, id) {
      obj.id = id;
      return this.save(obj);
    };

    Channel.prototype.save = function(obj) {
      return this.fire("send", Batman.SocketEvent.makeSaveEvent(obj, this.name));
    };

    Channel.prototype.read = function(id) {
      return this.fire("send", Batman.SocketEvent.makeReadEvent(id, this.name));
    };

    Channel.prototype.readAll = function() {
      return this.fire("send", Batman.SocketEvent.makeReadAllEvent(this.name));
    };

    Channel.prototype.remove = function(id) {
      return this.fire("send", Batman.SocketEvent.makeRemoveEvent(id, this.name));
    };

    Channel.prototype.lookup = function(field, query) {
      return this.fire("send", Batman.SocketEvent.makeLookupEvent(field, query, this.name));
    };

    Channel.prototype.query = function(query) {
      return this.fire("send", Batman.SocketEvent.makeQueryEvent(query, this.name));
    };

    Channel.prototype.stream2src = function(stream) {
      /*
        gets URL from the stream
      */

      if (window.URL != null) {
        return window.URL.createObjectURL(stream);
      } else {
        if (window.webkitURL != null) {
          return window.webkitURL.createObjectURL(stream);
        } else {
          if (window.mozURL != null) {
            return window.mozURL.createObjectURL(stream);
          } else {
            return stream;
          }
        }
      }
    };

    Channel.prototype.askWebcam = function() {
      return this.ask("webcam");
    };

    Channel.prototype.send = function(obj) {
      var data;
      data = Batman.SocketEvent.fromData(obj);
      data.channel = this.name;
      return this.fire("send", data);
    };

    Channel.prototype.receive = function(event) {
      this.fire("onmessage", event);
      return this.fire(event.request, event);
    };

    Channel.prototype.onNextMessage = function(fun) {
      var _this = this;
      return this.once("onmessage", function(event) {
        return fun(event);
      });
    };

    Channel.prototype.onmessage = function(event) {
      /*
        call back the receives info from socket send to this channel
      */

    };

    Channel.prototype.ask = function(question) {
      /*
        asks router for some additional info
      */

      return this.fire("ask", question);
    };

    Channel.prototype.attach = function(obj) {
      /*
        Attaches the channel to the socket wrapper and subscribes to its events
      */

      var cl, receive, send;
      receive = this.receive;
      obj.on(this.name, receive);
      obj.on("all", receive);
      send = obj.send;
      this.on("send", send);
      this.on("ask", obj.ask);
      cl = this.constructor.name;
      obj.fire(cl, this.name);
      return this;
    };

    return Channel;

  })(Batman.Object);

  /*
  # MockSocket class #
  Mock socket is needed for tests to simulate websocket behaviour
  */


  Batman.CacheSocket = (function(_super) {
    __extends(CacheSocket, _super);

    CacheSocket.prototype.isMock = true;

    CacheSocket.prototype.isCache = true;

    CacheSocket.prototype.input = [];

    CacheSocket.prototype.onopen = function() {
      /*
      Open event
      */

      return console.log("open");
    };

    function CacheSocket(url) {
      this.url = url;
      this.unapply = __bind(this.unapply, this);
      this.randomInt = __bind(this.randomInt, this);
      this.onclose = __bind(this.onclose, this);
      this.onerror = __bind(this.onerror, this);
      this.send = __bind(this.send, this);
      CacheSocket.__super__.constructor.apply(this, arguments);
      this.input = [];
    }

    CacheSocket.prototype.send = function(data) {
      return this.input.push(data);
    };

    CacheSocket.prototype.onmessage = function(event) {
      /*
      On message
      */

      var data;
      data = event.data;
      return console.log(data);
    };

    CacheSocket.prototype.onerror = function() {
      return console.log("error");
    };

    CacheSocket.prototype.onclose = function() {
      return console.log("close");
    };

    CacheSocket.prototype.randomInt = function(min, max) {
      /*
        random int generating function
      */

      return Math.floor(Math.random() * (max - min + 1)) + min;
    };

    CacheSocket.prototype.unapply = function(successor) {
      var el, _i, _len, _ref, _results;
      if ((this.input != null) && (successor.send != null)) {
        _ref = this.input;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          el = _ref[_i];
          _results.push(successor.send(el));
        }
        return _results;
      }
    };

    return CacheSocket;

  })(Batman.Object);

  /*
    #Socket class#
    it not only uses either real or mock socket but broadcasts messages to various channels through events
  */


  /*
    Routerclass
  */


  Batman.SimpleRouter = (function(_super) {
    __extends(SimpleRouter, _super);

    function SimpleRouter() {
      _ref = SimpleRouter.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    /*
      Simple router does only simple broadcasting relying on channel info from the socket
    */


    SimpleRouter.prototype.broadcast = function(info, socket) {
      /*
        transforms info into SocketEvents and routes them further, to the channels
        some routers split info into several parts and send to difference channels
      */

      var event;
      event = Batman.SocketEvent.fromEvent(info);
      /* broadcasts the message further*/

      if (!(event instanceof Batman.SocketEvent)) {
        throw Error('should be socket event');
      }
      /* broadcast event to appropriate channels*/

      socket.fire(event.channel, event);
      if ((event.room != null) && event.room !== "all") {
        return socket.fire(event.channel + "2" + event.room, event);
      }
    };

    SimpleRouter.prototype.send = function(obj, websocket) {
      /*
        sends event to the websocket
      */

      var str;
      if (typeof obj === 'string') {
        return websocket.send(obj);
      } else {
        str = JSON.stringify(Batman.SocketEvent.fromData(obj));
        return websocket.send(str);
      }
    };

    SimpleRouter.prototype.myStream = null;

    SimpleRouter.prototype.webCamPending = false;

    SimpleRouter.prototype.respond = function(question, socket) {
      /*
        respond to questions from channels
      */

      var onerror, onsuccess,
        _this = this;
      switch (question) {
        case "webcam":
          if (this.myStream != null) {
            return socket.fire("localStream", this.myStream);
          } else {
            if (this.webCamPending === false) {
              navigator.getUserMedia || (navigator.getUserMedia = navigator.mozGetUserMedia || navigator.webkitGetUserMedia || navigator.msGetUserMedia);
              if (navigator.getUserMedia) {
                onsuccess = function(stream) {
                  socket.fire("localStream", stream);
                  return _this.webCamPending = false;
                };
                onerror = this.onError;
                this.webCamPending = true;
                navigator.getUserMedia({
                  video: true,
                  audio: true
                }, onsuccess, onerror);
              } else {
                alert("getUserMedia is not supported in this browser.");
              }
            }
            return this.webCamPending = true;
          }
      }
    };

    return SimpleRouter;

  })(Batman.Object);

  Batman.Socket = (function(_super) {
    __extends(Socket, _super);

    /*
      websocket wrapper that broadcast info to its channels
      it not only uses either real or mock socket but broadcasts messages to various channels through events
    */


    function Socket(url) {
      this.ask = __bind(this.ask, this);
      this.send = __bind(this.send, this);
      this.getSpecialChannel = __bind(this.getSpecialChannel, this);
      this.getChannel = __bind(this.getChannel, this);
      this.withUrl = __bind(this.withUrl, this);
      this.getWebSocket = __bind(this.getWebSocket, this);
      this.addSocketHandlers = __bind(this.addSocketHandlers, this);
      this.setWebsocket = __bind(this.setWebsocket, this);
      this.createWebSocket = __bind(this.createWebSocket, this);
      this.isMock = __bind(this.isMock, this);
      /*
      creates a socket object
      */

      this.router = new Batman.SimpleRouter();
      this.websocket = this.getWebSocket(url);
      Batman.Socket.instance = this;
    }

    Socket.prototype.url = "none";

    Socket.prototype.isMock = function() {
      return (this.websocket == null) || (this.websocket.isMock != null);
    };

    Socket.prototype.createWebSocket = function(url) {
      /*
        creates websocket or mocksocket
      */

      var websocket;
      if (url === "none") {
        websocket = new Batman.CacheSocket(url);
      } else {
        websocket = new WebSocket(url);
      }
      this.url = url;
      return this.setWebsocket(websocket);
    };

    Socket.prototype.setWebsocket = function(websocket) {
      var defOpen, old,
        _this = this;
      defOpen = function(event) {
        _this.websocket = websocket;
        return _this.addSocketHandlers(_this.websocket);
      };
      if (this.websocket != null) {
        if (websocket === this.websocket) {
          return this.websocket;
        }
        if (this.websocket.isCache != null) {
          old = this.websocket;
          websocket.onopen = function(event) {
            defOpen(event);
            return old.unapply(websocket);
          };
        } else {
          websocket.onopen = defOpen;
        }
      } else {
        websocket.onopen = defOpen;
      }
      if (websocket.isMock != null) {
        return websocket.onopen();
      }
    };

    Socket.prototype.addSocketHandlers = function(websocket) {
      var _this = this;
      websocket.onmessage = function(event) {
        return _this.broadcast(event);
      };
      websocket.onerror = function(err) {
        return alert("some ERROR occured");
      };
      websocket.onclose = function() {
        return alert("socket is CLOSED");
      };
      return websocket;
    };

    Socket.prototype.broadcast = function(info) {
      return this.router.broadcast(info, this);
    };

    Socket.prototype.getWebSocket = function(url) {
      /*
        TODO: rewrite, all this searches, the global scope only confuses
      */

      if (Batman.container.websocket != null) {
        if ((Batman.container.websocket.isMock && url === 'none') || url === this.url) {
          return Batman.container.websocket;
        }
      }
      return this.createWebSocket(url);
    };

    Socket.prototype.withUrl = function(url) {
      /*
        returns self but changes the websocket if needed
      */

      if (url !== this.url) {
        this.websocket = this.getWebSocket(url);
      }
      return this;
    };

    Socket.getInstance = function(url) {
      if (url == null) {
        url = "none";
      }
      /*
        works as singletone
        TODO: rewrite
      */

      if (Batman.Socket.instance != null) {
        return Batman.Socket.instance;
      } else {
        return new Batman.Socket(url);
      }
    };

    /*
    if Batman.container.socket?
      return Batman.container.socket.withUrl(url)
    else
      return new Batman.Socket(url)
    */


    Socket.prototype.getChannel = function(name) {
      /*
        gets or creates channel
      */

      var _this = this;
      return this.getOrSet(name, function() {
        return new Batman.Channel(name).attach(_this);
      });
    };

    Socket.prototype.getSpecialChannel = function(name, factory) {
      /*
        gets or creates channel with factory that is provided
      */

      var _this = this;
      return this.getOrSet(name, function() {
        return factory().attach(_this);
      });
    };

    /*
    getVideoChannel: (name,room)=>
      #TODO: think how to fix in Future
      @getOrSet(name+"2"+room,=>new Batman.VideoChannel(name,room).attach(@))
    */


    Socket.prototype.send = function(obj) {
      return this.router.send(obj, this.websocket);
    };

    Socket.prototype.ask = function(question) {
      /*
        executes if there is a request to the router (but without info to be send to server)
      */

      return this.router.respond(question, this);
    };

    return Socket;

  }).call(this, Batman.Object);

}).call(this);

/*
//@ sourceMappingURL=sockets.map
*/
