// Generated by CoffeeScript 1.6.3
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Denigma.Curves = (function(_super) {
    __extends(Curves, _super);

    /*
      class to display lifespan curves
    */


    Curves.prototype.marginX = 15;

    Curves.prototype.marginY = 15;

    Curves.prototype.ticksY = 20;

    Curves.prototype.pointRad = 5;

    function Curves(selector, subclass, poser) {
      var funY;
      this.poser = poser != null ? poser : null;
      this.randColor = __bind(this.randColor, this);
      this.makeCoords = __bind(this.makeCoords, this);
      this.makePoint = __bind(this.makePoint, this);
      Curves.__super__.constructor.call(this, selector, subclass);
      this.xAxis = d3.svg.axis().orient("bottom");
      funY = function(t) {
        if (t === 0) {
          return "";
        } else {
          return t + "%";
        }
      };
      this.yAxis = d3.svg.axis().orient("right").ticks(this.ticksY).tickFormat(funY);
      this.svg.append("svg").attr("class", "xAxis");
      this.svg.append("svg").attr("class", "yAxis");
      this.svg.append("text").attr("id", "titleY").text("% alive");
      this.svg.append("text").attr("id", "titleX").text("time");
    }

    Curves.prototype.draw = function(data) {
      var max, novel, sel, yrMax;
      max = this.max(data);
      yrMax = this.height - this.marginY * 2;
      this.xScale = d3.scale.linear().domain([0, max]).range([this.marginX, this.width - this.marginX]);
      this.yScale = d3.scale.linear().domain([0, 100]).range([yrMax, this.marginY]);
      this.updateAxises(data);
      sel = this.select(data);
      this.hide(sel.exit());
      novel = this.append(sel.enter());
      return this.update(sel);
    };

    Curves.prototype.max = function(data) {
      return d3.max(data, function(d) {
        return d.get("max");
      });
    };

    Curves.prototype.append = function(novel) {
      var p, sv;
      sv = novel.append("svg");
      sv.attr("class", "" + this.subclass);
      p = sv.append("path");
      return novel;
    };

    Curves.prototype.makePoint = function(x, y, color) {
      return {
        x: x,
        y: y,
        c: color
      };
    };

    Curves.prototype.makeCoords = function(d) {
      /*
        creates coord array for curves
      */

      var alive, col, len, o, orgs, res, _i, _len;
      col = this.randColor();
      d.color = col;
      orgs = d.test.get("organisms").sort(function(a, b) {
        return a - b;
      });
      res = [this.makePoint(0, 100, col)];
      len = orgs.length;
      alive = len;
      for (_i = 0, _len = orgs.length; _i < _len; _i++) {
        o = orgs[_i];
        alive = alive - 1;
        res.push(this.makePoint(o, Math.round(alive / len * 100), col));
      }
      return res;
    };

    Curves.prototype.randColor = function() {
      return '#' + (0x1000000 + (Math.random()) * 0xffffff).toString(16).substr(1, 6);
    };

    Curves.prototype.update = function(sel) {
      var coords, data, getColor, getData, makePoly, path, points, poly, xFun, yFun,
        _this = this;
      xFun = function(d) {
        return _this.xScale(d.x);
      };
      yFun = function(d) {
        return _this.yScale(d.y);
      };
      poly = d3.svg.line().x(xFun).y(yFun).interpolate("monotone");
      coords = this.makeCoords;
      data = sel.data().map(function(d) {
        return coords(d);
      });
      path = sel.select("path");
      getData = function(d, i) {
        return data[i];
      };
      getColor = function(d, i) {
        return data[i][0].c;
      };
      makePoly = function(d, i) {
        return poly(data[i]);
      };
      path.attr("stroke", getColor).attr("fill", "none").attr("d", makePoly);
      sel.each(function(d, i) {
        var el, funOut, funOver,
          _this = this;
        el = $(this);
        funOver = function(dat) {
          return el.attr("stroke-width", 3);
        };
        funOut = function(dat) {
          return el.attr("stroke-width", 1);
        };
        d.on("over", funOver);
        return d.on("out", funOut);
      });
      sel.on("mouseover", function(d) {
        return d.fire("over", d);
      });
      sel.on("mouseout", function(d) {
        return d.fire("out", d);
      });
      points = sel.selectAll("circle.point").data(getData);
      points.exit().remove();
      points.enter().append("circle").attr("class", "point").attr("r", this.pointRad);
      return points.attr("cx", xFun).attr("cy", yFun).attr("fill", function(d) {
        return d.c;
      });
    };

    Curves.prototype.updateAxises = function(data) {
      var gx, gy;
      this.xAxis.scale(this.xScale);
      gx = this.svg.select("svg.xAxis");
      gx.attr("y", this.height - this.marginY * 2).call(this.xAxis);
      this.yAxis.scale(this.yScale);
      gy = this.svg.select("svg.yAxis");
      gy.attr("x", this.marginX).call(this.yAxis);
      this.svg.select("#" + "titleX").attr("x", this.width - this.marginX - 35).attr("y", this.height).text("time").style("font-size", 22);
      return this.svg.select("#titleY").attr("transform", "rotate(-90)").attr("x", 0 - this.height / 6 + this.marginY).attr("y", 0 - this.marginX).attr("dy", "1em").style("text-anchor", "middle").text("survival rate").style("font-size", 24);
    };

    return Curves;

  })(Denigma.Charts);

}).call(this);

/*
//@ sourceMappingURL=curves.map
*/
